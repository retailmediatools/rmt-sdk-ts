/* tslint:disable */
/* eslint-disable */
/**
 * Product Service
 * RMT Product API specification.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Catalog
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     *
     * @type {string}
     * @memberof Catalog
     */
    'catalog_key': string;
}
/**
 * Catalog Response
 * @export
 * @interface CatalogResponse
 */
export interface CatalogResponse {
    /**
     *
     * @type {string}
     * @memberof CatalogResponse
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CatalogResponse
     */
    'catalog_key': string;
    /**
     *
     * @type {string}
     * @memberof CatalogResponse
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof CatalogResponse
     */
    'updated_at': string;
}
/**
 *
 * @export
 * @interface CatalogResponseWrapper
 */
export interface CatalogResponseWrapper {
    /**
     *
     * @type {CatalogResponse}
     * @memberof CatalogResponseWrapper
     */
    'data': CatalogResponse;
}
/**
 *
 * @export
 * @interface CatalogsResponseWrapper
 */
export interface CatalogsResponseWrapper {
    /**
     *
     * @type {PageInfoResponse}
     * @memberof CatalogsResponseWrapper
     */
    'page_info'?: PageInfoResponse;
    /**
     *
     * @type {Array<CatalogResponse>}
     * @memberof CatalogsResponseWrapper
     */
    'data': Array<CatalogResponse>;
}
/**
 * Category
 * @export
 * @interface Category
 */
export interface Category {
    /**
     *
     * @type {string}
     * @memberof Category
     */
    'category_key': string;
    /**
     *
     * @type {string}
     * @memberof Category
     */
    'category_name': string;
}
/**
 *
 * @export
 * @interface CategoryResponseWrapper
 */
export interface CategoryResponseWrapper {
    /**
     *
     * @type {Category}
     * @memberof CategoryResponseWrapper
     */
    'data': Category;
}
/**
 *
 * @export
 * @interface DistinctResponseWrapper
 */
export interface DistinctResponseWrapper {
    /**
     *
     * @type {Array<any>}
     * @memberof DistinctResponseWrapper
     */
    'data': Array<any>;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     *
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': ErrorResponseCodeEnum;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     *
     * @type {string}
     * @memberof ErrorResponse
     */
    'status': ErrorResponseStatusEnum;
}

export const ErrorResponseCodeEnum = {
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_404: 404,
    NUMBER_409: 409,
    NUMBER_500: 500
} as const;

export type ErrorResponseCodeEnum = typeof ErrorResponseCodeEnum[keyof typeof ErrorResponseCodeEnum];
export const ErrorResponseStatusEnum = {
    Error: 'error'
} as const;

export type ErrorResponseStatusEnum = typeof ErrorResponseStatusEnum[keyof typeof ErrorResponseStatusEnum];

/**
 * Product inventories
 * @export
 * @interface Inventories
 */
export interface Inventories {
    /**
     *
     * @type {Array<Inventory>}
     * @memberof Inventories
     */
    'inventories': Array<Inventory>;
}
/**
 *
 * @export
 * @interface InventoriesResponseWrapper
 */
export interface InventoriesResponseWrapper {
    /**
     *
     * @type {Array<InventoryResponse>}
     * @memberof InventoriesResponseWrapper
     */
    'data': Array<InventoryResponse>;
}
/**
 * SKU store inventory
 * @export
 * @interface Inventory
 */
export interface Inventory {
    /**
     *
     * @type {string}
     * @memberof Inventory
     */
    'store_key': string;
    /**
     *
     * @type {number}
     * @memberof Inventory
     */
    'price_cents'?: number | null;
}
/**
 * SKU Inventory Response
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
    /**
     *
     * @type {string}
     * @memberof InventoryResponse
     */
    'store_key': string;
    /**
     *
     * @type {number}
     * @memberof InventoryResponse
     */
    'price_cents'?: number | null;
}
/**
 *
 * @export
 * @interface PageInfoResponse
 */
export interface PageInfoResponse {
    /**
     *
     * @type {string}
     * @memberof PageInfoResponse
     */
    'next_cursor'?: string;
    /**
     *
     * @type {string}
     * @memberof PageInfoResponse
     */
    'prev_cursor'?: string;
    /**
     *
     * @type {number}
     * @memberof PageInfoResponse
     */
    'total_count'?: number | null;
}
/**
 * Product Patch
 * @export
 * @interface PatchProduct
 */
export interface PatchProduct {
    /**
     *
     * @type {Array<string>}
     * @memberof PatchProduct
     */
    'gtins'?: Array<string> | null;
    /**
     *
     * @type {string}
     * @memberof PatchProduct
     */
    'image_url'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchProduct
     */
    'name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchProduct
     */
    'brand'?: string | null;
    /**
     *
     * @type {number}
     * @memberof PatchProduct
     */
    'base_price_cents'?: number | null;
    /**
     *
     * @type {string}
     * @memberof PatchProduct
     */
    'status'?: PatchProductStatusEnum;
    /**
     *
     * @type {Array<Category>}
     * @memberof PatchProduct
     */
    'categories'?: Array<Category> | null;
    /**
     *
     * @type {string}
     * @memberof PatchProduct
     */
    'import_file'?: string | null;
    /**
     *
     * @type {any}
     * @memberof PatchProduct
     */
    'custom'?: any;
}

export const PatchProductStatusEnum = {
    Active: 'ACTIVE'
} as const;

export type PatchProductStatusEnum = typeof PatchProductStatusEnum[keyof typeof PatchProductStatusEnum];

/**
 * Product
 * @export
 * @interface Product
 */
export interface Product {
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'sku': string;
    /**
     *
     * @type {Array<string>}
     * @memberof Product
     */
    'gtins'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'image_url'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'brand'?: string | null;
    /**
     *
     * @type {number}
     * @memberof Product
     */
    'base_price_cents'?: number | null;
    /**
     *
     * @type {Array<Category>}
     * @memberof Product
     */
    'categories'?: Array<Category>;
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'import_file'?: string | null;
    /**
     *
     * @type {any}
     * @memberof Product
     */
    'custom'?: any;
}
/**
 * Product Response
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     *
     * @type {string}
     * @memberof ProductResponse
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ProductResponse
     */
    'catalog_key': string;
    /**
     * Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'sku': string;
    /**
     * Can be used in the filter query string. Filters by exact GTIN match in the GTIN\'s list.
     * @type {Array<string>}
     * @memberof ProductResponse
     */
    'gtins': Array<string>;
    /**
     *
     * @type {string}
     * @memberof ProductResponse
     */
    'image_url'?: string | null;
    /**
     * Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'name'?: string | null;
    /**
     * Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'brand'?: string | null;
    /**
     * Can be used in the filter query string.
     * @type {number}
     * @memberof ProductResponse
     */
    'base_price_cents'?: number | null;
    /**
     * Can be used in the filter query string. Multiple choice filter is allowed.
     * @type {string}
     * @memberof ProductResponse
     */
    'status': ProductResponseStatusEnum;
    /**
     *
     * @type {number}
     * @memberof ProductResponse
     */
    'max_price_cents'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ProductResponse
     */
    'min_price_cents'?: number | null;
    /**
     * Can be used in the filter query string. The filter restriction should filter by category key.
     * @type {Array<Category>}
     * @memberof ProductResponse
     */
    'categories': Array<Category>;
    /**
     *
     * @type {string}
     * @memberof ProductResponse
     */
    'import_file'?: string | null;
    /**
     *
     * @type {any}
     * @memberof ProductResponse
     */
    'custom'?: any;
    /**
     * Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'created_at': string;
    /**
     * Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'updated_at': string;
}

export const ProductResponseStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type ProductResponseStatusEnum = typeof ProductResponseStatusEnum[keyof typeof ProductResponseStatusEnum];

/**
 *
 * @export
 * @interface ProductResponseWrapper
 */
export interface ProductResponseWrapper {
    /**
     *
     * @type {ProductResponse}
     * @memberof ProductResponseWrapper
     */
    'data': ProductResponse;
}
/**
 *
 * @export
 * @interface ProductsResponseWrapper
 */
export interface ProductsResponseWrapper {
    /**
     *
     * @type {PageInfoResponse}
     * @memberof ProductsResponseWrapper
     */
    'page_info': PageInfoResponse;
    /**
     *
     * @type {Array<ProductResponse>}
     * @memberof ProductsResponseWrapper
     */
    'data': Array<ProductResponse>;
}
/**
 * Product Update
 * @export
 * @interface UpdateProduct
 */
export interface UpdateProduct {
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateProduct
     */
    'gtins'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UpdateProduct
     */
    'image_url'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateProduct
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof UpdateProduct
     */
    'brand'?: string | null;
    /**
     *
     * @type {number}
     * @memberof UpdateProduct
     */
    'base_price_cents'?: number | null;
    /**
     *
     * @type {Array<Category>}
     * @memberof UpdateProduct
     */
    'categories'?: Array<Category>;
    /**
     *
     * @type {string}
     * @memberof UpdateProduct
     */
    'import_file'?: string | null;
    /**
     *
     * @type {any}
     * @memberof UpdateProduct
     */
    'custom'?: any;
}

/**
 * CatalogsApi - axios parameter creator
 * @export
 */
export const CatalogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create catalog
         * @param {Catalog} catalog A catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCatalog: async (catalog: Catalog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalog' is not null or undefined
            assertParamExists('addCatalog', 'catalog', catalog)
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:catalog"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get catalog
         * @param {string} catalogKey The catalog key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog: async (catalogKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getCatalog', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get catalogs
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs: async (limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the category data for a given category key in a Catalog.
         * @summary Get category data for a category key in a catalog
         * @param {string} catalogKey The catalog key where to look for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (catalogKey: string, categoryKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getCategory', 'catalogKey', catalogKey)
            // verify required parameter 'categoryKey' is not null or undefined
            assertParamExists('getCategory', 'categoryKey', categoryKey)
            const localVarPath = `/catalogs/{catalog_key}/categories/{category_key}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"category_key"}}`, encodeURIComponent(String(categoryKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get distinct values in a Catalog (brands, category names and/or keys).
         * @summary Get distinct values in a catalog
         * @param {string} catalogKey The catalog key where to look for the distinct values
         * @param {'brands' | 'categories' | 'category-keys' | 'category-names'} distinctKey Key for the distinct values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctValues: async (catalogKey: string, distinctKey: 'brands' | 'categories' | 'category-keys' | 'category-names', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getDistinctValues', 'catalogKey', catalogKey)
            // verify required parameter 'distinctKey' is not null or undefined
            assertParamExists('getDistinctValues', 'distinctKey', distinctKey)
            const localVarPath = `/catalogs/{catalog_key}/{distinct_key}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"distinct_key"}}`, encodeURIComponent(String(distinctKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogsApi - functional programming interface
 * @export
 */
export const CatalogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create catalog
         * @param {Catalog} catalog A catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCatalog(catalog: Catalog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCatalog(catalog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get catalog
         * @param {string} catalogKey The catalog key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalog(catalogKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalog(catalogKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get catalogs
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogs(limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogs(limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the category data for a given category key in a Catalog.
         * @summary Get category data for a category key in a catalog
         * @param {string} catalogKey The catalog key where to look for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(catalogKey: string, categoryKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(catalogKey, categoryKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get distinct values in a Catalog (brands, category names and/or keys).
         * @summary Get distinct values in a catalog
         * @param {string} catalogKey The catalog key where to look for the distinct values
         * @param {'brands' | 'categories' | 'category-keys' | 'category-names'} distinctKey Key for the distinct values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistinctValues(catalogKey: string, distinctKey: 'brands' | 'categories' | 'category-keys' | 'category-names', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistinctResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistinctValues(catalogKey, distinctKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CatalogsApi - factory interface
 * @export
 */
export const CatalogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogsApiFp(configuration)
    return {
        /**
         *
         * @summary Create catalog
         * @param {Catalog} catalog A catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCatalog(catalog: Catalog, options?: any): AxiosPromise<CatalogResponseWrapper> {
            return localVarFp.addCatalog(catalog, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get catalog
         * @param {string} catalogKey The catalog key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog(catalogKey: string, options?: any): AxiosPromise<CatalogResponseWrapper> {
            return localVarFp.getCatalog(catalogKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get catalogs
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs(limit?: number, cursor?: string, options?: any): AxiosPromise<CatalogsResponseWrapper> {
            return localVarFp.getCatalogs(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the category data for a given category key in a Catalog.
         * @summary Get category data for a category key in a catalog
         * @param {string} catalogKey The catalog key where to look for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(catalogKey: string, categoryKey: string, options?: any): AxiosPromise<CategoryResponseWrapper> {
            return localVarFp.getCategory(catalogKey, categoryKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get distinct values in a Catalog (brands, category names and/or keys).
         * @summary Get distinct values in a catalog
         * @param {string} catalogKey The catalog key where to look for the distinct values
         * @param {'brands' | 'categories' | 'category-keys' | 'category-names'} distinctKey Key for the distinct values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctValues(catalogKey: string, distinctKey: 'brands' | 'categories' | 'category-keys' | 'category-names', options?: any): AxiosPromise<DistinctResponseWrapper> {
            return localVarFp.getDistinctValues(catalogKey, distinctKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogsApi - object-oriented interface
 * @export
 * @class CatalogsApi
 * @extends {BaseAPI}
 */
export class CatalogsApi extends BaseAPI {
    /**
     *
     * @summary Create catalog
     * @param {Catalog} catalog A catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public addCatalog(catalog: Catalog, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).addCatalog(catalog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get catalog
     * @param {string} catalogKey The catalog key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalog(catalogKey: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCatalog(catalogKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get catalogs
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogs(limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCatalogs(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the category data for a given category key in a Catalog.
     * @summary Get category data for a category key in a catalog
     * @param {string} catalogKey The catalog key where to look for the category_key
     * @param {string} categoryKey Key for the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCategory(catalogKey: string, categoryKey: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCategory(catalogKey, categoryKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get distinct values in a Catalog (brands, category names and/or keys).
     * @summary Get distinct values in a catalog
     * @param {string} catalogKey The catalog key where to look for the distinct values
     * @param {'brands' | 'categories' | 'category-keys' | 'category-names'} distinctKey Key for the distinct values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getDistinctValues(catalogKey: string, distinctKey: 'brands' | 'categories' | 'category-keys' | 'category-names', options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getDistinctValues(catalogKey, distinctKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InventoriesApi - axios parameter creator
 * @export
 */
export const InventoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventories: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getInventories', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getInventories', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}/inventories`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:inventory"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventories: async (catalogKey: string, sku: string, inventories: Inventories, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('putInventories', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('putInventories', 'sku', sku)
            // verify required parameter 'inventories' is not null or undefined
            assertParamExists('putInventories', 'inventories', inventories)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}/inventories`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:inventory"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventories, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoriesApi - functional programming interface
 * @export
 */
export const InventoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoriesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventories(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoriesResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventories(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInventories(catalogKey, sku, inventories, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InventoriesApi - factory interface
 * @export
 */
export const InventoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoriesApiFp(configuration)
    return {
        /**
         *
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventories(catalogKey: string, sku: string, options?: any): AxiosPromise<InventoriesResponseWrapper> {
            return localVarFp.getInventories(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: any): AxiosPromise<void> {
            return localVarFp.putInventories(catalogKey, sku, inventories, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoriesApi - object-oriented interface
 * @export
 * @class InventoriesApi
 * @extends {BaseAPI}
 */
export class InventoriesApi extends BaseAPI {
    /**
     *
     * @summary Get inventories
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getInventories(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getInventories(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product inventory
     * @summary Add inventories
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {Inventories} inventories An array of product inventories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).putInventories(catalogKey, sku, inventories, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create product
         * @param {string} catalogKey The catalog key where to get the products
         * @param {Product} product A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (catalogKey: string, product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('addProduct', 'catalogKey', catalogKey)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/catalogs/{catalog_key}/products`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('deactivateProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('deactivateProduct', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getProduct', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:product"], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get products in a catalog
         * @param {string} catalogKey The catalog key where to get the products
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getProducts', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}/products`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:product"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update particular field(s) of a specific Product.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct: async (catalogKey: string, sku: string, patchProduct: PatchProduct, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('patchProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('patchProduct', 'sku', sku)
            // verify required parameter 'patchProduct' is not null or undefined
            assertParamExists('patchProduct', 'patchProduct', patchProduct)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProduct: async (catalogKey: string, sku: string, updateProduct: UpdateProduct, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('putProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('putProduct', 'sku', sku)
            // verify required parameter 'updateProduct' is not null or undefined
            assertParamExists('putProduct', 'updateProduct', updateProduct)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create product
         * @param {string} catalogKey The catalog key where to get the products
         * @param {Product} product A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(catalogKey: string, product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(catalogKey, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateProduct(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get products in a catalog
         * @param {string} catalogKey The catalog key where to get the products
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(catalogKey, q, filter, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update particular field(s) of a specific Product.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProduct(catalogKey, sku, patchProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProduct(catalogKey, sku, updateProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         *
         * @summary Create product
         * @param {string} catalogKey The catalog key where to get the products
         * @param {Product} product A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(catalogKey: string, product: Product, options?: any): AxiosPromise<ProductResponseWrapper> {
            return localVarFp.addProduct(catalogKey, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct(catalogKey: string, sku: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateProduct(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(catalogKey: string, sku: string, options?: any): AxiosPromise<ProductResponseWrapper> {
            return localVarFp.getProduct(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get products in a catalog
         * @param {string} catalogKey The catalog key where to get the products
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit]
         * @param {string} [cursor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, options?: any): AxiosPromise<ProductsResponseWrapper> {
            return localVarFp.getProducts(catalogKey, q, filter, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Update particular field(s) of a specific Product.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: any): AxiosPromise<void> {
            return localVarFp.patchProduct(catalogKey, sku, patchProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: any): AxiosPromise<void> {
            return localVarFp.putProduct(catalogKey, sku, updateProduct, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     *
     * @summary Create product
     * @param {string} catalogKey The catalog key where to get the products
     * @param {Product} product A product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(catalogKey: string, product: Product, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).addProduct(catalogKey, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a Product. Products are never deleted permanently.
     * @summary Deactivate product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deactivateProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deactivateProduct(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get products in a catalog
     * @param {string} catalogKey The catalog key where to get the products
     * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
     * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
     * @param {number} [limit]
     * @param {string} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProducts(catalogKey, q, filter, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update particular field(s) of a specific Product.
     * @summary Update product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {PatchProduct} patchProduct A product patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).patchProduct(catalogKey, sku, patchProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific Product. A complete object must be provided.
     * @summary Update product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {UpdateProduct} updateProduct A product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).putProduct(catalogKey, sku, updateProduct, options).then((request) => request(this.axios, this.basePath));
    }
}
