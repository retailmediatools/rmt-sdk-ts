/* tslint:disable */
/* eslint-disable */
/**
 * Product Service
 * RMT Product API specification.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Catalog
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    'catalog_key': string;
}
/**
 * Catalog Response
 * @export
 * @interface CatalogResponse
 */
export interface CatalogResponse {
    /**
     * 
     * @type {string}
     * @memberof CatalogResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogResponse
     */
    'catalog_key': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CatalogResponseWrapper
 */
export interface CatalogResponseWrapper {
    /**
     * 
     * @type {CatalogResponse}
     * @memberof CatalogResponseWrapper
     */
    'data': CatalogResponse;
}
/**
 * 
 * @export
 * @interface CatalogsResponseWrapper
 */
export interface CatalogsResponseWrapper {
    /**
     * 
     * @type {PageInfoResponse}
     * @memberof CatalogsResponseWrapper
     */
    'page_info'?: PageInfoResponse;
    /**
     * 
     * @type {Array<CatalogResponse>}
     * @memberof CatalogsResponseWrapper
     */
    'data': Array<CatalogResponse>;
}
/**
 * Represents a product category.
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Unique identifier for the category.
     * @type {string}
     * @memberof Category
     */
    'category_key': string;
    /**
     * The name of the product category.
     * @type {string}
     * @memberof Category
     */
    'category_name': string;
}
/**
 * 
 * @export
 * @interface CategoryResponseWrapper
 */
export interface CategoryResponseWrapper {
    /**
     * 
     * @type {Category}
     * @memberof CategoryResponseWrapper
     */
    'data': Category;
}
/**
 * 
 * @export
 * @interface CreateImportSessionRequest
 */
export interface CreateImportSessionRequest {
    /**
     * Optional URI of a file that should be used for the import. If left unspecified, entities can be imported by using the \'Import entities\' API.
     * @type {string}
     * @memberof CreateImportSessionRequest
     */
    'uri'?: string;
}
/**
 * 
 * @export
 * @interface DistinctBrandsResponseWrapper
 */
export interface DistinctBrandsResponseWrapper {
    /**
     * 
     * @type {PageInfoResponse}
     * @memberof DistinctBrandsResponseWrapper
     */
    'page_info'?: PageInfoResponse;
    /**
     * 
     * @type {Array<string>}
     * @memberof DistinctBrandsResponseWrapper
     */
    'data': Array<string>;
}
/**
 * 
 * @export
 * @interface DistinctCategoriesResponseWrapper
 */
export interface DistinctCategoriesResponseWrapper {
    /**
     * 
     * @type {PageInfoResponse}
     * @memberof DistinctCategoriesResponseWrapper
     */
    'page_info'?: PageInfoResponse;
    /**
     * 
     * @type {Array<any>}
     * @memberof DistinctCategoriesResponseWrapper
     */
    'data': Array<any>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': ErrorResponseCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'status': ErrorResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'request_id': string;
}

export const ErrorResponseCodeEnum = {
    NUMBER_400: 400,
    NUMBER_401: 401,
    NUMBER_404: 404,
    NUMBER_409: 409,
    NUMBER_422: 422,
    NUMBER_500: 500
} as const;

export type ErrorResponseCodeEnum = typeof ErrorResponseCodeEnum[keyof typeof ErrorResponseCodeEnum];
export const ErrorResponseStatusEnum = {
    Error: 'error'
} as const;

export type ErrorResponseStatusEnum = typeof ErrorResponseStatusEnum[keyof typeof ErrorResponseStatusEnum];

/**
 * @type ImportEntitiesRequest
 * @export
 */
export type ImportEntitiesRequest = InventoriesWrapper | ProductsWrapper;

/**
 * 
 * @export
 * @interface ImportOperation
 */
export interface ImportOperation {
    /**
     * 
     * @type {string}
     * @memberof ImportOperation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImportOperation
     */
    'status': ImportOperationStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportOperation
     */
    'messages'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ImportOperation
     */
    'created_at': string;
}

export const ImportOperationStatusEnum = {
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type ImportOperationStatusEnum = typeof ImportOperationStatusEnum[keyof typeof ImportOperationStatusEnum];

/**
 * 
 * @export
 * @interface ImportOperationResponse
 */
export interface ImportOperationResponse {
    /**
     * 
     * @type {ImportOperationResponseData}
     * @memberof ImportOperationResponse
     */
    'data': ImportOperationResponseData;
}
/**
 * 
 * @export
 * @interface ImportOperationResponseData
 */
export interface ImportOperationResponseData {
    /**
     * 
     * @type {string}
     * @memberof ImportOperationResponseData
     */
    'id': string;
}
/**
 * Product to Import
 * @export
 * @interface ImportProduct
 */
export interface ImportProduct {
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'sku': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportProduct
     */
    'gtins'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'brand'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ImportProduct
     */
    'base_price_cents'?: number | null;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ImportProduct
     */
    'categories'?: Array<Category>;
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'import_file'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ImportProduct
     */
    'custom'?: any;
    /**
     * 
     * @type {string}
     * @memberof ImportProduct
     */
    'status'?: ImportProductStatusEnum;
}

export const ImportProductStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type ImportProductStatusEnum = typeof ImportProductStatusEnum[keyof typeof ImportProductStatusEnum];

/**
 * 
 * @export
 * @interface ImportSession
 */
export interface ImportSession {
    /**
     * 
     * @type {string}
     * @memberof ImportSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImportSession
     */
    'status': ImportSessionStatusEnum;
    /**
     * 
     * @type {Array<ImportOperation>}
     * @memberof ImportSession
     */
    'operations'?: Array<ImportOperation>;
    /**
     * 
     * @type {string}
     * @memberof ImportSession
     */
    'created_at': string;
}

export const ImportSessionStatusEnum = {
    Idle: 'IDLE',
    Importing: 'IMPORTING'
} as const;

export type ImportSessionStatusEnum = typeof ImportSessionStatusEnum[keyof typeof ImportSessionStatusEnum];

/**
 * 
 * @export
 * @interface ImportSessionResponseWrapper
 */
export interface ImportSessionResponseWrapper {
    /**
     * 
     * @type {ImportSession}
     * @memberof ImportSessionResponseWrapper
     */
    'data': ImportSession;
}
/**
 * 
 * @export
 * @interface ImportSessionsResponseWrapper
 */
export interface ImportSessionsResponseWrapper {
    /**
     * 
     * @type {Array<ImportSession>}
     * @memberof ImportSessionsResponseWrapper
     */
    'data': Array<ImportSession>;
}
/**
 * Represents the inventories of a product across multiple stores.
 * @export
 * @interface Inventories
 */
export interface Inventories {
    /**
     * 
     * @type {Array<Inventory>}
     * @memberof Inventories
     */
    'inventories': Array<Inventory>;
}
/**
 * 
 * @export
 * @interface InventoriesResponseWrapper
 */
export interface InventoriesResponseWrapper {
    /**
     * 
     * @type {Array<InventoryResponse>}
     * @memberof InventoriesResponseWrapper
     */
    'data': Array<InventoryResponse>;
}
/**
 * 
 * @export
 * @interface InventoriesWrapper
 */
export interface InventoriesWrapper {
    /**
     * 
     * @type {Array<ProductInventories>}
     * @memberof InventoriesWrapper
     */
    'inventories'?: Array<ProductInventories>;
}
/**
 * Represents the inventory of a product in a store.
 * @export
 * @interface Inventory
 */
export interface Inventory {
    /**
     * Unique identifier for the store.
     * @type {string}
     * @memberof Inventory
     */
    'store_key': string;
    /**
     * Price of the product in the store.
     * @type {number}
     * @memberof Inventory
     */
    'price_cents'?: number | null;
}
/**
 * Represents the response for the inventory of a product in a store.
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
    /**
     * Unique identifier for the store.
     * @type {string}
     * @memberof InventoryResponse
     */
    'store_key': string;
    /**
     * 
     * @type {number}
     * @memberof InventoryResponse
     */
    'price_cents'?: number | null;
}
/**
 * 
 * @export
 * @interface PageInfoResponse
 */
export interface PageInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof PageInfoResponse
     */
    'next_cursor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PageInfoResponse
     */
    'prev_cursor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponse
     */
    'total_count'?: number | null;
}
/**
 * Product Patch
 * @export
 * @interface PatchProduct
 */
export interface PatchProduct {
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchProduct
     */
    'gtins'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProduct
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProduct
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProduct
     */
    'brand'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchProduct
     */
    'base_price_cents'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProduct
     */
    'status'?: PatchProductStatusEnum;
    /**
     * 
     * @type {Array<Category>}
     * @memberof PatchProduct
     */
    'categories'?: Array<Category> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProduct
     */
    'import_file'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof PatchProduct
     */
    'custom'?: any;
}

export const PatchProductStatusEnum = {
    Active: 'ACTIVE'
} as const;

export type PatchProductStatusEnum = typeof PatchProductStatusEnum[keyof typeof PatchProductStatusEnum];

/**
 * Product
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sku': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'gtins'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'brand'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'base_price_cents'?: number | null;
    /**
     * 
     * @type {Array<Category>}
     * @memberof Product
     */
    'categories'?: Array<Category>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'import_file'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Product
     */
    'custom'?: any;
}
/**
 * Represents a list of inventories for a product.
 * @export
 * @interface ProductInventories
 */
export interface ProductInventories {
    /**
     * 
     * @type {string}
     * @memberof ProductInventories
     */
    'sku': string;
    /**
     * 
     * @type {Array<Inventory>}
     * @memberof ProductInventories
     */
    'inventories'?: Array<Inventory> | null;
}
/**
 * Represents the response for a product.
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * Unique identifier for the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'id': string;
    /**
     * Unique identifier for the catalog to which the product belongs.
     * @type {string}
     * @memberof ProductResponse
     */
    'catalog_key': string;
    /**
     * Stock Keeping Unit. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'sku': string;
    /**
     * List of Global Trade Item Numbers (GTINs) associated with the product.
     * @type {Array<string>}
     * @memberof ProductResponse
     */
    'gtins': Array<string>;
    /**
     * URL of the product image.
     * @type {string}
     * @memberof ProductResponse
     */
    'image_url'?: string | null;
    /**
     * Name of the product. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'name'?: string | null;
    /**
     * Brand of the product. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'brand'?: string | null;
    /**
     * Base price of the product. Can be used in the filter query string.
     * @type {number}
     * @memberof ProductResponse
     */
    'base_price_cents'?: number | null;
    /**
     * Status of the product. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'status': ProductResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductResponse
     */
    'max_price_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProductResponse
     */
    'min_price_cents'?: number | null;
    /**
     * Categories describing the product. Can be used in the filter query string.
     * @type {Array<Category>}
     * @memberof ProductResponse
     */
    'categories': Array<Category>;
    /**
     * File from which the product was imported.
     * @type {string}
     * @memberof ProductResponse
     */
    'import_file'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ProductResponse
     */
    'custom'?: any;
    /**
     * Timestamp of when the product was created. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'created_at': string;
    /**
     * Timestamp of the last update to the product. Can be used in the filter query string.
     * @type {string}
     * @memberof ProductResponse
     */
    'updated_at': string;
}

export const ProductResponseStatusEnum = {
    Active: 'ACTIVE',
    Archived: 'ARCHIVED'
} as const;

export type ProductResponseStatusEnum = typeof ProductResponseStatusEnum[keyof typeof ProductResponseStatusEnum];

/**
 * 
 * @export
 * @interface ProductResponseWrapper
 */
export interface ProductResponseWrapper {
    /**
     * 
     * @type {ProductResponse}
     * @memberof ProductResponseWrapper
     */
    'data': ProductResponse;
}
/**
 * 
 * @export
 * @interface ProductsResponseWrapper
 */
export interface ProductsResponseWrapper {
    /**
     * 
     * @type {PageInfoResponse}
     * @memberof ProductsResponseWrapper
     */
    'page_info'?: PageInfoResponse;
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof ProductsResponseWrapper
     */
    'data': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface ProductsWrapper
 */
export interface ProductsWrapper {
    /**
     * 
     * @type {Array<ImportProduct>}
     * @memberof ProductsWrapper
     */
    'products'?: Array<ImportProduct>;
}
/**
 * Product Update
 * @export
 * @interface UpdateProduct
 */
export interface UpdateProduct {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProduct
     */
    'gtins': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateProduct
     */
    'image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProduct
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProduct
     */
    'brand': string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProduct
     */
    'base_price_cents': number | null;
    /**
     * 
     * @type {Array<Category>}
     * @memberof UpdateProduct
     */
    'categories': Array<Category>;
    /**
     * 
     * @type {string}
     * @memberof UpdateProduct
     */
    'import_file': string | null;
    /**
     * 
     * @type {any}
     * @memberof UpdateProduct
     */
    'custom'?: any;
}

/**
 * CatalogsApi - axios parameter creator
 * @export
 */
export const CatalogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create catalog
         * @param {Catalog} catalog A catalog request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCatalog: async (catalog: Catalog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalog' is not null or undefined
            assertParamExists('addCatalog', 'catalog', catalog)
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:catalog"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog: async (catalogKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getCatalog', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List catalogs
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs: async (limit?: number, cursor?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Category data for a given Category key in a Catalog.
         * @summary Get category data
         * @param {string} catalogKey The key of the catalog to search for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (catalogKey: string, categoryKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getCategory', 'catalogKey', catalogKey)
            // verify required parameter 'categoryKey' is not null or undefined
            assertParamExists('getCategory', 'categoryKey', categoryKey)
            const localVarPath = `/catalogs/{catalog_key}/categories/{category_key}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"category_key"}}`, encodeURIComponent(String(categoryKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve distinct brands in a Catalog.
         * @summary Get distinct brands in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct brands
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctBrands: async (catalogKey: string, limit?: number, cursor?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getDistinctBrands', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}/brands`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve distinct categories in a Catalog.
         * @summary Get distinct categories in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct categories
         * @param {'category_key' | 'category_name'} [key] Specifies the field to return. If not specified, the response will contain the full category object.
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctCategories: async (catalogKey: string, key?: 'category_key' | 'category_name', limit?: number, cursor?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getDistinctCategories', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}/categories`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogsApi - functional programming interface
 * @export
 */
export const CatalogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create catalog
         * @param {Catalog} catalog A catalog request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCatalog(catalog: Catalog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCatalog(catalog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalog(catalogKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalog(catalogKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List catalogs
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogs(limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogs(limit, cursor, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the Category data for a given Category key in a Catalog.
         * @summary Get category data
         * @param {string} catalogKey The key of the catalog to search for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(catalogKey: string, categoryKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(catalogKey, categoryKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve distinct brands in a Catalog.
         * @summary Get distinct brands in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct brands
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistinctBrands(catalogKey: string, limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistinctBrandsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistinctBrands(catalogKey, limit, cursor, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve distinct categories in a Catalog.
         * @summary Get distinct categories in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct categories
         * @param {'category_key' | 'category_name'} [key] Specifies the field to return. If not specified, the response will contain the full category object.
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDistinctCategories(catalogKey: string, key?: 'category_key' | 'category_name', limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistinctCategoriesResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDistinctCategories(catalogKey, key, limit, cursor, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CatalogsApi - factory interface
 * @export
 */
export const CatalogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create catalog
         * @param {Catalog} catalog A catalog request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCatalog(catalog: Catalog, options?: any): AxiosPromise<CatalogResponseWrapper> {
            return localVarFp.addCatalog(catalog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog(catalogKey: string, options?: any): AxiosPromise<CatalogResponseWrapper> {
            return localVarFp.getCatalog(catalogKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List catalogs
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs(limit?: number, cursor?: string, orderBy?: string, options?: any): AxiosPromise<CatalogsResponseWrapper> {
            return localVarFp.getCatalogs(limit, cursor, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Category data for a given Category key in a Catalog.
         * @summary Get category data
         * @param {string} catalogKey The key of the catalog to search for the category_key
         * @param {string} categoryKey Key for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(catalogKey: string, categoryKey: string, options?: any): AxiosPromise<CategoryResponseWrapper> {
            return localVarFp.getCategory(catalogKey, categoryKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve distinct brands in a Catalog.
         * @summary Get distinct brands in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct brands
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctBrands(catalogKey: string, limit?: number, cursor?: string, orderBy?: string, options?: any): AxiosPromise<DistinctBrandsResponseWrapper> {
            return localVarFp.getDistinctBrands(catalogKey, limit, cursor, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve distinct categories in a Catalog.
         * @summary Get distinct categories in a catalog
         * @param {string} catalogKey The key of the catalog to search for distinct categories
         * @param {'category_key' | 'category_name'} [key] Specifies the field to return. If not specified, the response will contain the full category object.
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinctCategories(catalogKey: string, key?: 'category_key' | 'category_name', limit?: number, cursor?: string, orderBy?: string, options?: any): AxiosPromise<DistinctCategoriesResponseWrapper> {
            return localVarFp.getDistinctCategories(catalogKey, key, limit, cursor, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogsApi - object-oriented interface
 * @export
 * @class CatalogsApi
 * @extends {BaseAPI}
 */
export class CatalogsApi extends BaseAPI {
    /**
     * 
     * @summary Create catalog
     * @param {Catalog} catalog A catalog request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public addCatalog(catalog: Catalog, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).addCatalog(catalog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get catalog
     * @param {string} catalogKey The key of the catalog to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalog(catalogKey: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCatalog(catalogKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List catalogs
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogs(limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCatalogs(limit, cursor, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Category data for a given Category key in a Catalog.
     * @summary Get category data
     * @param {string} catalogKey The key of the catalog to search for the category_key
     * @param {string} categoryKey Key for the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCategory(catalogKey: string, categoryKey: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getCategory(catalogKey, categoryKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve distinct brands in a Catalog.
     * @summary Get distinct brands in a catalog
     * @param {string} catalogKey The key of the catalog to search for distinct brands
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getDistinctBrands(catalogKey: string, limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getDistinctBrands(catalogKey, limit, cursor, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve distinct categories in a Catalog.
     * @summary Get distinct categories in a catalog
     * @param {string} catalogKey The key of the catalog to search for distinct categories
     * @param {'category_key' | 'category_name'} [key] Specifies the field to return. If not specified, the response will contain the full category object.
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getDistinctCategories(catalogKey: string, key?: 'category_key' | 'category_name', limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).getDistinctCategories(catalogKey, key, limit, cursor, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportsApi - axios parameter creator
 * @export
 */
export const ImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {CreateImportSessionRequest} createImportSessionRequest An import session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportSession: async (catalogKey: string, createImportSessionRequest: CreateImportSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('createImportSession', 'catalogKey', catalogKey)
            // verify required parameter 'createImportSessionRequest' is not null or undefined
            assertParamExists('createImportSession', 'createImportSessionRequest', createImportSessionRequest)
            const localVarPath = `/catalogs/{catalog_key}/imports`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:catalog"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImportSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImportSession: async (catalogKey: string, importId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('deleteImportSession', 'catalogKey', catalogKey)
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('deleteImportSession', 'importId', importId)
            const localVarPath = `/catalogs/{catalog_key}/imports/{import_id}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:catalog"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportSession: async (catalogKey: string, importId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getImportSession', 'catalogKey', catalogKey)
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('getImportSession', 'importId', importId)
            const localVarPath = `/catalogs/{catalog_key}/imports/{import_id}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import entities
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {string} importId Unique identifier of the import session to add the product batch to
         * @param {ImportEntitiesRequest} importEntitiesRequest An entity import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEntities: async (catalogKey: string, importId: string, importEntitiesRequest: ImportEntitiesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('importEntities', 'catalogKey', catalogKey)
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('importEntities', 'importId', importId)
            // verify required parameter 'importEntitiesRequest' is not null or undefined
            assertParamExists('importEntities', 'importEntitiesRequest', importEntitiesRequest)
            const localVarPath = `/catalogs/{catalog_key}/imports/{import_id}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importEntitiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List import sessions
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportSessions: async (catalogKey: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('listImportSessions', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}/imports`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:catalog"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportsApi - functional programming interface
 * @export
 */
export const ImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {CreateImportSessionRequest} createImportSessionRequest An import session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportSession(catalogKey: string, createImportSessionRequest: CreateImportSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportSessionResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportSession(catalogKey, createImportSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImportSession(catalogKey: string, importId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImportSession(catalogKey, importId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportSession(catalogKey: string, importId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportSessionResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportSession(catalogKey, importId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import entities
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {string} importId Unique identifier of the import session to add the product batch to
         * @param {ImportEntitiesRequest} importEntitiesRequest An entity import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEntities(catalogKey: string, importId: string, importEntitiesRequest: ImportEntitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEntities(catalogKey, importId, importEntitiesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List import sessions
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportSessions(catalogKey: string, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportSessionsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImportSessions(catalogKey, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportsApi - factory interface
 * @export
 */
export const ImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {CreateImportSessionRequest} createImportSessionRequest An import session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportSession(catalogKey: string, createImportSessionRequest: CreateImportSessionRequest, options?: any): AxiosPromise<ImportSessionResponseWrapper> {
            return localVarFp.createImportSession(catalogKey, createImportSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImportSession(catalogKey: string, importId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImportSession(catalogKey, importId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get import session
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {string} importId Unique identifier of the import session to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportSession(catalogKey: string, importId: string, options?: any): AxiosPromise<ImportSessionResponseWrapper> {
            return localVarFp.getImportSession(catalogKey, importId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import entities
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {string} importId Unique identifier of the import session to add the product batch to
         * @param {ImportEntitiesRequest} importEntitiesRequest An entity import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEntities(catalogKey: string, importId: string, importEntitiesRequest: ImportEntitiesRequest, options?: any): AxiosPromise<ImportOperationResponse> {
            return localVarFp.importEntities(catalogKey, importId, importEntitiesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List import sessions
         * @param {string} catalogKey The key of the catalog to retrieve
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportSessions(catalogKey: string, limit?: number, cursor?: string, options?: any): AxiosPromise<ImportSessionsResponseWrapper> {
            return localVarFp.listImportSessions(catalogKey, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportsApi - object-oriented interface
 * @export
 * @class ImportsApi
 * @extends {BaseAPI}
 */
export class ImportsApi extends BaseAPI {
    /**
     * 
     * @summary Create import session
     * @param {string} catalogKey The key of the catalog to retrieve
     * @param {CreateImportSessionRequest} createImportSessionRequest An import session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public createImportSession(catalogKey: string, createImportSessionRequest: CreateImportSessionRequest, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).createImportSession(catalogKey, createImportSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete import session
     * @param {string} catalogKey The key of the catalog to retrieve
     * @param {string} importId Unique identifier of the import session to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public deleteImportSession(catalogKey: string, importId: string, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).deleteImportSession(catalogKey, importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get import session
     * @param {string} catalogKey The key of the catalog to retrieve
     * @param {string} importId Unique identifier of the import session to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public getImportSession(catalogKey: string, importId: string, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).getImportSession(catalogKey, importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import entities
     * @param {string} catalogKey The key of the catalog to add the product to
     * @param {string} importId Unique identifier of the import session to add the product batch to
     * @param {ImportEntitiesRequest} importEntitiesRequest An entity import request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importEntities(catalogKey: string, importId: string, importEntitiesRequest: ImportEntitiesRequest, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importEntities(catalogKey, importId, importEntitiesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List import sessions
     * @param {string} catalogKey The key of the catalog to retrieve
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public listImportSessions(catalogKey: string, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).listImportSessions(catalogKey, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InventoriesApi - axios parameter creator
 * @export
 */
export const InventoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventories: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getInventories', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getInventories', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}/inventories`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:inventory"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventories: async (catalogKey: string, sku: string, inventories: Inventories, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('putInventories', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('putInventories', 'sku', sku)
            // verify required parameter 'inventories' is not null or undefined
            assertParamExists('putInventories', 'inventories', inventories)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}/inventories`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inventories, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoriesApi - functional programming interface
 * @export
 */
export const InventoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventories(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoriesResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventories(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInventories(catalogKey, sku, inventories, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InventoriesApi - factory interface
 * @export
 */
export const InventoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventories(catalogKey: string, sku: string, options?: any): AxiosPromise<InventoriesResponseWrapper> {
            return localVarFp.getInventories(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product inventory
         * @summary Add inventories
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {Inventories} inventories An array of product inventories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: any): AxiosPromise<void> {
            return localVarFp.putInventories(catalogKey, sku, inventories, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoriesApi - object-oriented interface
 * @export
 * @class InventoriesApi
 * @extends {BaseAPI}
 */
export class InventoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get inventories
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getInventories(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getInventories(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product inventory
     * @summary Add inventories
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {Inventories} inventories An array of product inventories request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public putInventories(catalogKey: string, sku: string, inventories: Inventories, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).putInventories(catalogKey, sku, inventories, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create product
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {Product} product A product request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (catalogKey: string, product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('addProduct', 'catalogKey', catalogKey)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/catalogs/{catalog_key}/products`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('deactivateProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('deactivateProduct', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (catalogKey: string, sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getProduct', 'sku', sku)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:product"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get products in a catalog
         * @param {string} catalogKey The key of the catalog to retrieve products from
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('getProducts', 'catalogKey', catalogKey)
            const localVarPath = `/catalogs/{catalog_key}/products`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["read-all:product"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update particular field(s) of a specific Product
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct: async (catalogKey: string, sku: string, patchProduct: PatchProduct, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('patchProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('patchProduct', 'sku', sku)
            // verify required parameter 'patchProduct' is not null or undefined
            assertParamExists('patchProduct', 'patchProduct', patchProduct)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProduct: async (catalogKey: string, sku: string, updateProduct: UpdateProduct, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogKey' is not null or undefined
            assertParamExists('putProduct', 'catalogKey', catalogKey)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('putProduct', 'sku', sku)
            // verify required parameter 'updateProduct' is not null or undefined
            assertParamExists('putProduct', 'updateProduct', updateProduct)
            const localVarPath = `/catalogs/{catalog_key}/products/{sku}`
                .replace(`{${"catalog_key"}}`, encodeURIComponent(String(catalogKey)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", ["write-all:product"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create product
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {Product} product A product request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(catalogKey: string, product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(catalogKey, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateProduct(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(catalogKey, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get products in a catalog
         * @param {string} catalogKey The key of the catalog to retrieve products from
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(catalogKey, q, filter, limit, cursor, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update particular field(s) of a specific Product
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProduct(catalogKey, sku, patchProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProduct(catalogKey, sku, updateProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create product
         * @param {string} catalogKey The key of the catalog to add the product to
         * @param {Product} product A product request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(catalogKey: string, product: Product, options?: any): AxiosPromise<ProductResponseWrapper> {
            return localVarFp.addProduct(catalogKey, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a Product. Products are never deleted permanently.
         * @summary Deactivate product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct(catalogKey: string, sku: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateProduct(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(catalogKey: string, sku: string, options?: any): AxiosPromise<ProductResponseWrapper> {
            return localVarFp.getProduct(catalogKey, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get products in a catalog
         * @param {string} catalogKey The key of the catalog to retrieve products from
         * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
         * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, orderBy?: string, options?: any): AxiosPromise<ProductsResponseWrapper> {
            return localVarFp.getProducts(catalogKey, q, filter, limit, cursor, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update particular field(s) of a specific Product
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {PatchProduct} patchProduct A product patch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: any): AxiosPromise<void> {
            return localVarFp.patchProduct(catalogKey, sku, patchProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific Product. A complete object must be provided.
         * @summary Update product
         * @param {string} catalogKey The catalog key
         * @param {string} sku The product sku
         * @param {UpdateProduct} updateProduct A product update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: any): AxiosPromise<void> {
            return localVarFp.putProduct(catalogKey, sku, updateProduct, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Create product
     * @param {string} catalogKey The key of the catalog to add the product to
     * @param {Product} product A product request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(catalogKey: string, product: Product, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).addProduct(catalogKey, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a Product. Products are never deleted permanently.
     * @summary Deactivate product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deactivateProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deactivateProduct(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(catalogKey: string, sku: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(catalogKey, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get products in a catalog
     * @param {string} catalogKey The key of the catalog to retrieve products from
     * @param {string} [q] The query for a search in the catalog\&#39;s products. Compared to the &#x60;filter&#x60; parameter, one would use the &#x60;q&#x60; parameter to perform a text search over the catalog\&#39;s products. Meanwhile, &#x60;filter&#x60; filters the output based on the individual field values.
     * @param {string} [filter] Filter the result. See filtering query basics at [Filtering concept](https://docs.retailmediatools.com/reference/filtering). Due to implementation limitations, only the following operators are supported: &#x60;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;AND&#x60;. Use &#x60;OR&#x60; to filter by multi-choice fields, such as &#x60;status&#x60;
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {string} [orderBy] Specifies the sorting order. The default sorting order is descending. To specify ascending order for a field, append a &#x60;asc&#x60; suffix; for example: &#x60;created_at asc&#x60;. Redundant space characters in the syntax are insignificant. &#x60;foo, bar asc&#x60;, &#x60; foo , bar asc &#x60;, and &#x60;foo,bar asc&#x60; are all equivalent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(catalogKey: string, q?: string, filter?: string, limit?: number, cursor?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProducts(catalogKey, q, filter, limit, cursor, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update particular field(s) of a specific Product
     * @summary Update product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {PatchProduct} patchProduct A product patch request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public patchProduct(catalogKey: string, sku: string, patchProduct: PatchProduct, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).patchProduct(catalogKey, sku, patchProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific Product. A complete object must be provided.
     * @summary Update product
     * @param {string} catalogKey The catalog key
     * @param {string} sku The product sku
     * @param {UpdateProduct} updateProduct A product update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public putProduct(catalogKey: string, sku: string, updateProduct: UpdateProduct, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).putProduct(catalogKey, sku, updateProduct, options).then((request) => request(this.axios, this.basePath));
    }
}


